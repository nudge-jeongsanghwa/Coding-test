## 풀이 방법

> 1. 실행 대기 큐(Queue)에서 대기중인 프로세스 하나를 꺼냅니다.
> 2. 큐에 대기중인 프로세스 중 우선순위가 더 높은 프로세스가 있다면 방금 꺼낸 프로세스를 다시 큐에 넣습니다.
> 3. 만약 그런 프로세스가 없다면 방금 꺼낸 프로세스를 실행합니다.
  3.1 한 번 실행한 프로세스는 다시 큐에 넣지 않고 그대로 종료됩니다.

문제 조건 중에서 2번에 대한 처리가 중요하다고 생각하고 문제를 풀이하였습니다.

이를 위해서 `priority_list`라는 우선순위가 오름차순으로 정렬된 리스트와 이터레이터 `it`을 선언하였습니다.

> if q[0][0] < priority_list[it][0]:

15번째 라인을 통하여 큐에 대기 중인 프로세스보다 우선순위가 더 높은 프로세스가 있는 경우에는 큐를 `pop`한 뒤, 다시 `append` 해줍니다.


```python
else:
    answer += 1
    tmp = q.popleft()
    if tmp[0] == priority_list[it][0]:
        it -= 1
    
    if tmp[1] == location:
        return answer
```

나머지 18번째 라인부터는 대기 중인 큐가 나갈 수 있는 경우입니다.
 우선순위가 가장 높은 프로세스가 밖으로 나왔을 것이므로 it도 1 감소시켜줍니다.

`location`과 `tmp[1]`이 같은 경우가 찾고자 하는 프로세스이므로 이때 `answer`를 반환합니다. 

## Tip

`sorted`를 통한 정렬을 1회만 수행하고 이터레이터를 통하여 잔여 프로세스 중 가장 높은 우선순위를 관리하면 전체 시간복잡도를 O(nlogn)으로 가져갈 수 있습니다.