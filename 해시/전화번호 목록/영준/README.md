## 풀이 방법

해시를 사용해 풀이합니다.

각 숫자와 숫자의 일부를 해시로 저장해서 시간복잡도의 단순화를 노립니다.

숫자 배열의 길이를 n(<= 1,000,000), 각 숫자의 길이를 m(<= 20)이라고 했을 때, 본 풀이의 시간복잡도는 O(n*m)입니다.


### 기본 설정

아래 두 개의 set을 정의합니다.
- prefixSet: 접두어로 기능할 가능성이 있는 숫자 저장
- numSet: 접두어를 가질 가능성이 있는 숫자 저장


### 반복문1: 숫자 배열 순회
접두어 짝을 찾으면 false를, 하나도 못 찾으면 true를 반환해야 합니다.

phone_book 배열을 순회하며 하나라도 false가 나올 경우(접두어 짝을 찾을 경우) 바로 false를 반환할 수 있도록 every 메소드를 사용해 순회합니다.


### 조건문1: 현재 숫자 접두어 사용 가능 여부 확인

지나온 숫자들 중에 현재 숫자를 접두어로 가지는 숫자가 있는지 확인합니다. 있다면, false를 반환합니다.


### 반복문2: 현재 숫자의 각 자릿수 순회

현재 숫자의 앞에서부터 하나씩 prefix라는 변수에 붙여가며 순회합니다.


### 조건문2: 지나온 숫자 접두어 사용 가능 여부 확인

지나온 숫자 중에 현재 숫자의 접두어인 숫자가 있는지 확인합니다. 있다면, false를 반환합니다.


### 숫자 저장1: numSet

현재 숫자의 접두어가 될 수 있는 모든 경우의 수의 숫자들을 numSet에 저장합니다.


### 숫자 저장2: prefixSet

현재 숫자를 접두어로 가지는 숫자를 이후에 판단하기 위해 현재 숫자를 prefixSet에 저장합니다.


### 마무리

마지막으로 아무 것도 찾지 못했다면 true를 반환합니다.


## Tip

위의 풀이는 O(n*m)의 시간복잡도를 가지지만, 풀이과정이 조금 복잡하고 코드가 깁니다. 시간복잡도를 조금 손해본다면, 아래와 같이 정렬을 사용해 비교적 간결한 풀이를 사용할 수도 있습니다. 또한 일일이 해시를 사용해 숫자를 저장하지 않는 만큼, 공간복잡도도 줄어듭니다.

숫자 배열의 길이를 n(<= 1,000,000)이라고 했을 때, 아래 풀이의 시간복잡도는 O(n*log(n))이 됩니다. log(100000000)은 대략 26.575의 값을 가집니다. 그렇다면 위의 풀이는 100000000 * 20, 아래 풀이는 100000000 * 26.575이므로, 단순 수학적으로 계산했을 때, 시간복잡도면에서 아주 큰 손해도 아닙니다.

더 재밌는 사실은, 프로그래머스의 효율성 테스트 결과입니다. 아래는 각 풀이의 효율성 테스트 값입니다. 단위는 ms입니다.

- 위  풀이:  0.24 / 0.24 / 766.47 / 545.29
- 아래 풀이: 3.92 / 3.92 / 153.53 / 119.54

보면, 최선의 경우에는 위의 풀이가 우월하지만, 최악의 경우에는 아래의 풀이가 더 우월하다는 것을 알 수 있습니다.

```js
// 추가 풀이 1
return phone_book.sort().every((v, i, arr) => i === 0 ? true : v.indexOf(arr[i-1]) !== 0)

// 추가 풀이 2
return !phone_book.sort().some((v, i, arr) => i === 0 ? false : v.startsWith(arr[i-1]))
```